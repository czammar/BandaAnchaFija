Sigma.f = array(0, c(dx, dx, T0))
mu.s = matrix(0, nrow = dx, ncol = T0)
Sigma.s = array(0, c(dx, dx, T0))
## FORWARD RECURSION ## Time 1
mu.p[, 1] = F %*% mu0
Sigma.p[, , 1] = F %*% Sigma0 %*% t(F) + G %*% Q %*% t(G)
nu = y[, 1] - H %*% mu.p[, 1]
S = H %*% Sigma.p[, , 1] %*% t(H) + R
K = Sigma.p[, , 1] %*% t(H) %*% solve(S)
mu.f[, 1] = mu.p[, 1] + K %*% nu
Sigma.f[, , 1] = (I - K %*% H) %*% Sigma.p[, , 1]
# Time 2:T
for (t in (2:T0)){
# Prediction
mu.p[, t] = F %*% mu.f[, t - 1]
Sigma.p[, , t] = F %*% Sigma.f[, , t - 1] %*% t(F) + G %*% Q %*% t(G)
# Update
nu = y[, t] - H %*% mu.p[, t]
S = H %*% Sigma.p[, , t] %*% t(H) + R
K = Sigma.p[, , t] %*% t(H) %*% solve(S)
mu.f[, t] = mu.p[, t] + K %*% nu
Sigma.f[, , t] = (I - K %*% H) %*% Sigma.p[, , t]}
## BACKWARD RECURSION ##
mu.s[, T0] = mu.f[, T0]
Sigma.s[, , T0] = Sigma.f[, , T0]
for (t in (T0 - 1):1){
J = Sigma.f[, , t] %*% t(F) %*% solve(Sigma.p[, , t + 1])
mu.s[, t] = mu.f[, t] + J %*% (mu.s[, t + 1] - mu.p[, t + 1])
Sigma.s[, , t] = Sigma.f[, , t] + J %*% (Sigma.s[, , t + 1] - Sigma.p[,, t + 1]) %*% t(J)
}
return(list(mu.f = mu.f, Sigma.f = Sigma.f, mu.p = mu.p, Sigma.p = Sigma.p,mu.s = mu.s, Sigma.s = Sigma.s))
}
T0 = 50
x = matrix(cos(c(1:T0)/10), 1, T0)
R = 0.2
mu0 = 0
Sigma0 = 1
G = 1
Q = 0.02
H = 1
F0 = 1
y = matrix(x + rnorm(T0, sd = sqrt(R)), nrow = 1, ncol = T0)
results.KF = kalman(y, F0, G, Q, H, R, mu0, Sigma0)
mu.f = results.KF$mu.f
Sigma.f = results.KF$Sigma.f
mu.p = results.KF$mu.p
mu.s = results.KF$mu.s
ggplot()+ geom_point(aes(1:50,mu.p[1,], color = 'red'))+geom_point(aes(1:50,y[1,], color = 'blue'))
?gamma
?dgamma
alpha1 <- 16/136.5
beta1 <- alpha1/136.5
s1 <- 1/beta1
# probabilidad de que theta sea menor a 0.1
pgamma(0.1, alpha1, s1)
alpha1 <- 16/136.5
beta1 <- alpha1/136.5
s1 <- 1/beta1
# probabilidad de que theta sea menor a 0.1
pgamma(0.1, alpha1, s1)
alpha1 <- 16/136.5
beta1 <- alpha1/136.5
s1 <- 1/beta1
# probabilidad de que theta sea menor a 0.1
pgamma(0.1, alpha1, s1)
alpha1 <- 16/136.5
beta1 <- alpha1/136.5
s1 <- 1/beta1
# probabilidad de que theta sea menor a 0.1
pgamma(0.1, alpha1, s1)
qgamma(0.1, alpha1, s1)
pgamma(0.01, alpha1, s1)
?pnorm
pnorm(0.01, mu1, sigma1)
# Ejercicio 6 b)
# Simulacion para caso 1
mu1 <- 16/136.5
sigma1 <- alpha1/136.5
# probabilidad de que theta sea menor a 0.1
pnorm(0.01, mu1, sigma1)
# Ejercicio 6 b)
# Simulacion para caso 1
mu1 <- 16/136.5
sigma1 <- alpha1/136.5
# probabilidad de que theta sea menor a 0.1
pnorm(0.01, mu1, sigma1)
sigma1 <- alpha1/136.5
# Ejercicio 6 b)
# Simulacion para caso 1
mu1 <- 16/136.5
sigma1 <- mu1/136.5
# probabilidad de que theta sea menor a 0.1
pnorm(0.01, mu1, sigma1)
# Ejercicio 6 b)
# Simulacion para caso 1
mu1 <- 16/136.5
sigma1 <- mu1/136.5
# probabilidad de que theta sea menor a 0.1
pnorm(0.1, mu1, sigma1)
mu2 <- 9/92.5
sigma2 <- mu2/92.5
# probabilidad de que theta sea menor a 0.1
pnorm(0.1, mu2, sigma2)
# probabilidad de que theta sea menor a 0.1
print("Caso 1")
pnorm(0.1, mu1, sigma1)
###### ----- Simulacion para caso 2 ----- ######
mu2 <- 9/92.5
sigma2 <- mu2/92.5
# probabilidad de que theta sea menor a 0.1
print("Caso 2")
pnorm(0.1, mu2, sigma2)
print("Caso 1")
pnorm(0.1, mu1, sigma1)
mu1 <- 16/136.5
sigma1 <- mu1/136.5
# probabilidad de que theta sea menor a 0.1
print("Caso 1")
pnorm(0.1, mu1, sigma1)
mu2 <- 9/92.5
sigma2 <- mu2/92.5
# probabilidad de que theta sea menor a 0.1
print("Caso 2")
pnorm(0.1, mu2, sigma2)
N = 14; z = 11; a = 1; b = 1
base <- ggplot(data_frame(x = c(0, 1)), aes(x))
p1 <- base +
stat_function(fun = dbeta, args = list(shape1 = a, shape2 = b), #inicial
aes(colour = "inicial"), show.legend = FALSE) +
stat_function(fun = dbeta, args = list(shape1 = z + 1, shape2 = N - z + 1), #verosimilitud
aes(colour = "verosimilitud"), show.legend = FALSE) +
stat_function(fun = dbeta, args = list(shape1 = a + z, shape2 = N - z + b), #posterior
aes(colour = "posterior"), show.legend = FALSE) +
labs(y = "", colour = "", x = expression(theta))
N = 14; z = 11; a = 100; b = 100
p2 <- base +
stat_function(fun = dbeta, args = list(shape1 = a, shape2 = b),
aes(colour = "inicial")) +
stat_function(fun = dbeta, args = list(shape1 = z + 1, shape2 = N - z + 1),
aes(colour = "verosimilitud")) +
stat_function(fun = dbeta, args = list(shape1 = a + z, shape2 = N - z + b),
aes(colour = "posterior")) +
labs(y = "", colour = "", x = expression(theta))
grid.arrange(p1, p2, nrow = 1, widths = c(0.38, 0.62))
library("tidyverse")
N = 14; z = 11; a = 1; b = 1
base <- ggplot(data_frame(x = c(0, 1)), aes(x))
p1 <- base +
stat_function(fun = dbeta, args = list(shape1 = a, shape2 = b), #inicial
aes(colour = "inicial"), show.legend = FALSE) +
stat_function(fun = dbeta, args = list(shape1 = z + 1, shape2 = N - z + 1), #verosimilitud
aes(colour = "verosimilitud"), show.legend = FALSE) +
stat_function(fun = dbeta, args = list(shape1 = a + z, shape2 = N - z + b), #posterior
aes(colour = "posterior"), show.legend = FALSE) +
labs(y = "", colour = "", x = expression(theta))
N = 14; z = 11; a = 100; b = 100
p2 <- base +
stat_function(fun = dbeta, args = list(shape1 = a, shape2 = b),
aes(colour = "inicial")) +
stat_function(fun = dbeta, args = list(shape1 = z + 1, shape2 = N - z + 1),
aes(colour = "verosimilitud")) +
stat_function(fun = dbeta, args = list(shape1 = a + z, shape2 = N - z + b),
aes(colour = "posterior")) +
labs(y = "", colour = "", x = expression(theta))
grid.arrange(p1, p2, nrow = 1, widths = c(0.38, 0.62))
library(gridExtra)
library(grid)
N = 14; z = 11; a = 1; b = 1
base <- ggplot(data_frame(x = c(0, 1)), aes(x))
p1 <- base +
stat_function(fun = dbeta, args = list(shape1 = a, shape2 = b), #inicial
aes(colour = "inicial"), show.legend = FALSE) +
stat_function(fun = dbeta, args = list(shape1 = z + 1, shape2 = N - z + 1), #verosimilitud
aes(colour = "verosimilitud"), show.legend = FALSE) +
stat_function(fun = dbeta, args = list(shape1 = a + z, shape2 = N - z + b), #posterior
aes(colour = "posterior"), show.legend = FALSE) +
labs(y = "", colour = "", x = expression(theta))
N = 14; z = 11; a = 100; b = 100
p2 <- base +
stat_function(fun = dbeta, args = list(shape1 = a, shape2 = b),
aes(colour = "inicial")) +
stat_function(fun = dbeta, args = list(shape1 = z + 1, shape2 = N - z + 1),
aes(colour = "verosimilitud")) +
stat_function(fun = dbeta, args = list(shape1 = a + z, shape2 = N - z + b),
aes(colour = "posterior")) +
labs(y = "", colour = "", x = expression(theta))
grid.arrange(p1, p2, nrow = 1, widths = c(0.38, 0.62))
library(gridExtra)
library(grid)
N = 14; z = 11; a = 1; b = 1
base <- ggplot(data_frame(x = c(0, 1)), aes(x))
p1 <- base +
stat_function(fun = dbeta, args = list(shape1 = a, shape2 = b), #inicial
aes(colour = "inicial"), show.legend = FALSE) +
stat_function(fun = dbeta, args = list(shape1 = z + 1, shape2 = N - z + 1), #verosimilitud
aes(colour = "verosimilitud"), show.legend = FALSE) +
stat_function(fun = dbeta, args = list(shape1 = a + z, shape2 = N - z + b), #posterior
aes(colour = "posterior"), show.legend = FALSE) +
labs(y = "", colour = "", x = expression(theta))
N = 14; z = 11; a = 100; b = 100
p2 <- base +
stat_function(fun = dbeta, args = list(shape1 = a, shape2 = b),
aes(colour = "inicial")) +
stat_function(fun = dbeta, args = list(shape1 = z + 1, shape2 = N - z + 1),
aes(colour = "verosimilitud")) +
stat_function(fun = dbeta, args = list(shape1 = a + z, shape2 = N - z + b),
aes(colour = "posterior")) +
labs(y = "", colour = "", x = expression(theta))
grid.arrange(p1, p2, nrow = 1, widths = c(0.38, 0.62))
View(p1)
p1
p2
grid.arrange(p1, p2, nrow = 1, widths = c(0.38, 0.62))
library(readr)
library(tidyverse)
library(ggplot2)
#library("tidyverse")
######---- Carga base de datos de accesos de banda ancha fija ----######
BAF_raw <- read_csv("TODO_BAF/TD_ACC_BAF_ITE_VA.csv",
col_types = cols(ANIO = col_character(),
K_ACCESO_INTERNET = col_character(),
K_ENTIDAD = col_character(), K_MUNICIPIO = col_character(),
MES = col_character()), locale = locale(encoding = "ISO-8859-1"))
######---- Transformacion y limpieza de la base de accesos ----#####
## Crea una llave para cruzar con las otras bases
BAF_study <- BAF_raw
BAF_study$K_MUNICIPIO <- substr(BAF_study$K_MUNICIPIO,3,5)
BAF_study <- BAF_study  %>% mutate(K_ENTIDAD_MUNICIPIO = paste(K_ENTIDAD, K_MUNICIPIO, sep = ""))
## seleccion variable y alarga la bases de accesos por tecnologia
# suma los accesos de todos los operadores en el municipio por tecnologia
BAF_study <- BAF_study %>%  select(K_ENTIDAD_MUNICIPIO,K_ENTIDAD,K_MUNICIPIO, ANIO, MES,K_ACCESO_INTERNET, A_TOTAL_E) %>%
group_by(K_ENTIDAD_MUNICIPIO,K_ENTIDAD,K_MUNICIPIO, ANIO, MES,K_ACCESO_INTERNET) %>% summarise_all(funs(sum))
BAF_study <- BAF_study %>% ungroup()
BAF_study<- BAF_study %>% spread(K_ACCESO_INTERNET, A_TOTAL_E)
## El detalle de accesos a nivel municipal con NA se imputa con cero
BAF_study <- BAF_study %>% mutate_all(~replace(., is.na(.), 0))
# Renombramos columnas de accesos segun su tecnologia
names(BAF_study)[6] <- "CABLE_COAXIAL"
names(BAF_study)[7] <- "DSL"
names(BAF_study)[8] <- "FIBRA_OPTICA"
names(BAF_study)[9] <- "SATELITAL"
names(BAF_study)[10] <- "TERRESTRE_FIJO_INALAMBRICO"
names(BAF_study)[11] <- "OTRAS_TECNOLOGIAS"
names(BAF_study)[12] <- "SIN_TECNOLOGIA_ESPECIFICADA"
# Agregamos columna de todos los accesos del municipio
BAF_study <- BAF_study %>% mutate(ALL_ACCESS = CABLE_COAXIAL+DSL+FIBRA_OPTICA+SATELITAL+TERRESTRE_FIJO_INALAMBRICO+OTRAS_TECNOLOGIAS+SIN_TECNOLOGIA_ESPECIFICADA)
# Agregamos columna de todos los accesos cable coaxial y fibra optica del municipio
BAF_study <- BAF_study %>% mutate(COAX_FO = CABLE_COAXIAL+FIBRA_OPTICA)
# Se excluyen los datos de accesos que no tienen ubicacion de municipio
BAF_062019 <-  subset(BAF_study, ANIO == "2019" & MES == "06" & K_ENTIDAD != "99"  & K_MUNICIPIO != "999" )
# ----- Contamos la cantidad de empresas presentes en el municipio
# Filtramos la base en crudo para junio de 2019
BAF_raw062019<- BAF_raw %>%filter(ANIO=="2019" & MES == "06" & K_ENTIDAD != "99"  & K_MUNICIPIO != "999" )
## Crea una llave para cruzar con las otras bases
BAF_raw062019$K_MUNICIPIO <- substr(BAF_raw062019$K_MUNICIPIO,3,5)
BAF_raw062019 <- BAF_raw062019  %>% mutate(K_ENTIDAD_MUNICIPIO = paste(K_ENTIDAD, K_MUNICIPIO, sep = ""))
# Crea la base auxiliar que tiene por clave de municipio la cantidad de empresas de BAF en esta
BAF_study_ops <- BAF_raw062019 %>% select(K_ENTIDAD_MUNICIPIO) %>% unique()
BAF_study_ops$NUM_OPS <-NA
for (i in 1:nrow(BAF_study_ops)){
folio =BAF_study_ops$K_ENTIDAD_MUNICIPIO[i]
n <- BAF_raw062019 %>% select(EMPRESA,K_ENTIDAD_MUNICIPIO) %>% filter(K_ENTIDAD_MUNICIPIO == BAF_study_ops$K_ENTIDAD_MUNICIPIO[i]) %>% unique() %>% nrow()
BAF_study_ops$NUM_OPS[i]= n
}
# Agrega un columna de la cantidad total de empresas que cuentan con al menos un acceso de BAF en cada municipio
BAF_062019 <- left_join(BAF_062019,BAF_study_ops, by = "K_ENTIDAD_MUNICIPIO")
#----- Escribe la base final
write_csv(BAF_062019, "BAF_06209.csv")
# Eliminamos objetos auxiliares
rm(BAF_raw,BAF_study,folio,i,n,BAF_study_ops,BAF_raw062019)
####---- Resumenes
# # Tabla resumen de conexiones por anio
# year_resume <- BAF_raw %>% select(ANIO, MES, A_TOTAL_E) %>% group_by(ANIO,MES) %>%
#   summarize(n=sum(A_TOTAL_E,na.rm = TRUE)/1000000) %>% ungroup()
#
# year_resume <- mutate(year_resume, key_yearmonth = paste(year_resume$ANIO, year_resume$MES,sep = ""))
#
# #ggplot(year_resume, aes(key_yearmonth, n)) + geom_bar(stat = "identity")
#
# # Tabla resumen de conexiones por anio, con desagregacion de tecnologia
# technology_resume<-BAF_raw %>% select(ANIO, MES, K_ACCESO_INTERNET, TECNO_ACCESO_INTERNET, A_TOTAL_E) %>% group_by(ANIO, MES, K_ACCESO_INTERNET, TECNO_ACCESO_INTERNET) %>%
#   summarize(n=sum(A_TOTAL_E,na.rm = TRUE)/1000000) %>% ungroup()
setwd("/media/Box/Aprendizaje_Maquina/Projecto")
library(readr)
library(tidyverse)
library(ggplot2)
#library("tidyverse")
######---- Carga base de datos de accesos de banda ancha fija ----######
BAF_raw <- read_csv("TODO_BAF/TD_ACC_BAF_ITE_VA.csv",
col_types = cols(ANIO = col_character(),
K_ACCESO_INTERNET = col_character(),
K_ENTIDAD = col_character(), K_MUNICIPIO = col_character(),
MES = col_character()), locale = locale(encoding = "ISO-8859-1"))
######---- Transformacion y limpieza de la base de accesos ----#####
## Crea una llave para cruzar con las otras bases
BAF_study <- BAF_raw
BAF_study$K_MUNICIPIO <- substr(BAF_study$K_MUNICIPIO,3,5)
BAF_study <- BAF_study  %>% mutate(K_ENTIDAD_MUNICIPIO = paste(K_ENTIDAD, K_MUNICIPIO, sep = ""))
## seleccion variable y alarga la bases de accesos por tecnologia
# suma los accesos de todos los operadores en el municipio por tecnologia
BAF_study <- BAF_study %>%  select(K_ENTIDAD_MUNICIPIO,K_ENTIDAD,K_MUNICIPIO, ANIO, MES,K_ACCESO_INTERNET, A_TOTAL_E) %>%
group_by(K_ENTIDAD_MUNICIPIO,K_ENTIDAD,K_MUNICIPIO, ANIO, MES,K_ACCESO_INTERNET) %>% summarise_all(funs(sum))
BAF_study <- BAF_study %>% ungroup()
BAF_study<- BAF_study %>% spread(K_ACCESO_INTERNET, A_TOTAL_E)
## El detalle de accesos a nivel municipal con NA se imputa con cero
BAF_study <- BAF_study %>% mutate_all(~replace(., is.na(.), 0))
# Renombramos columnas de accesos segun su tecnologia
names(BAF_study)[6] <- "CABLE_COAXIAL"
names(BAF_study)[7] <- "DSL"
names(BAF_study)[8] <- "FIBRA_OPTICA"
names(BAF_study)[9] <- "SATELITAL"
names(BAF_study)[10] <- "TERRESTRE_FIJO_INALAMBRICO"
names(BAF_study)[11] <- "OTRAS_TECNOLOGIAS"
names(BAF_study)[12] <- "SIN_TECNOLOGIA_ESPECIFICADA"
# Agregamos columna de todos los accesos del municipio
BAF_study <- BAF_study %>% mutate(ALL_ACCESS = CABLE_COAXIAL+DSL+FIBRA_OPTICA+SATELITAL+TERRESTRE_FIJO_INALAMBRICO+OTRAS_TECNOLOGIAS+SIN_TECNOLOGIA_ESPECIFICADA)
# Agregamos columna de todos los accesos cable coaxial y fibra optica del municipio
BAF_study <- BAF_study %>% mutate(COAX_FO = CABLE_COAXIAL+FIBRA_OPTICA)
# Se excluyen los datos de accesos que no tienen ubicacion de municipio
BAF_062019 <-  subset(BAF_study, ANIO == "2019" & MES == "06" & K_ENTIDAD != "99"  & K_MUNICIPIO != "999" )
# ----- Contamos la cantidad de empresas presentes en el municipio
# Filtramos la base en crudo para junio de 2019
BAF_raw062019<- BAF_raw %>%filter(ANIO=="2019" & MES == "06" & K_ENTIDAD != "99"  & K_MUNICIPIO != "999" )
## Crea una llave para cruzar con las otras bases
BAF_raw062019$K_MUNICIPIO <- substr(BAF_raw062019$K_MUNICIPIO,3,5)
BAF_raw062019 <- BAF_raw062019  %>% mutate(K_ENTIDAD_MUNICIPIO = paste(K_ENTIDAD, K_MUNICIPIO, sep = ""))
# Crea la base auxiliar que tiene por clave de municipio la cantidad de empresas de BAF en esta
BAF_study_ops <- BAF_raw062019 %>% select(K_ENTIDAD_MUNICIPIO) %>% unique()
BAF_study_ops$NUM_OPS <-NA
for (i in 1:nrow(BAF_study_ops)){
folio =BAF_study_ops$K_ENTIDAD_MUNICIPIO[i]
n <- BAF_raw062019 %>% select(EMPRESA,K_ENTIDAD_MUNICIPIO) %>% filter(K_ENTIDAD_MUNICIPIO == BAF_study_ops$K_ENTIDAD_MUNICIPIO[i]) %>% unique() %>% nrow()
BAF_study_ops$NUM_OPS[i]= n
}
# Agrega un columna de la cantidad total de empresas que cuentan con al menos un acceso de BAF en cada municipio
BAF_062019 <- left_join(BAF_062019,BAF_study_ops, by = "K_ENTIDAD_MUNICIPIO")
#----- Escribe la base final
write_csv(BAF_062019, "BAF_06209.csv")
# Eliminamos objetos auxiliares
rm(BAF_raw,BAF_study,folio,i,n,BAF_study_ops,BAF_raw062019)
####---- Resumenes
# # Tabla resumen de conexiones por anio
# year_resume <- BAF_raw %>% select(ANIO, MES, A_TOTAL_E) %>% group_by(ANIO,MES) %>%
#   summarize(n=sum(A_TOTAL_E,na.rm = TRUE)/1000000) %>% ungroup()
#
# year_resume <- mutate(year_resume, key_yearmonth = paste(year_resume$ANIO, year_resume$MES,sep = ""))
#
# #ggplot(year_resume, aes(key_yearmonth, n)) + geom_bar(stat = "identity")
#
# # Tabla resumen de conexiones por anio, con desagregacion de tecnologia
# technology_resume<-BAF_raw %>% select(ANIO, MES, K_ACCESO_INTERNET, TECNO_ACCESO_INTERNET, A_TOTAL_E) %>% group_by(ANIO, MES, K_ACCESO_INTERNET, TECNO_ACCESO_INTERNET) %>%
#   summarize(n=sum(A_TOTAL_E,na.rm = TRUE)/1000000) %>% ungroup()
View(BAF_062019)
View(BAF_062019)
library(readr)
library(tidyverse)
library(readxl)
# Establece directorio de trabajo
setwd("/media/Box/Aprendizaje_Maquina/Projecto")
# Crear las bases de datos para trabajar
source("creating_baf.R") # Accesos de banda ancha fija a junio/2019 BIT del IFT
source("creating_conapo.R") # Indice marginacion y porcentaje pob con menos de 2 salarios min, 2015 CONAPO
source("creating_inafed.R") # Superficie de municipios, INAFED
source("creating_indiceinfraestructura.R")  # Indice infraestructura TII - centro de estudios IFT
source("creating_hogares.R") # Hogares por municipios Encuesta intercensal 2015, INEGI
source("creating_poblacion.R") # Poblacion por municipios Encuesta intercensal 2015, INEGI
# Elimina variables auxiliares
rm(index, left_path,name_state,right_path,states_list,cleaning_hog_state,cleaning_pop_state)
# Consolidamos las bases
df <- left_join(hogares2015,poblacion2015, by = "K_ENTIDAD_MUNICIPIO")
df <- left_join(df,conapo, by = "K_ENTIDAD_MUNICIPIO")
df <- left_join(df,INAFED, by = "K_ENTIDAD_MUNICIPIO")
df <- left_join(df,infraestructura_index, by = "K_ENTIDAD_MUNICIPIO")
df <- left_join(df,BAF_062019, by = "K_ENTIDAD_MUNICIPIO")
df$SUPERFICIE<- as.numeric(df$SUPERFICIE)
df$df$PO2SM<- as.numeric(df$PO2SM)
# Se eliminan columas sin interes para el analisis
df$K_ENTIDAD<-NULL
df$K_MUNICIPIO<-NULL
df$ANIO<-NULL
df$MES<-NULL
## El detalle de accesos a nivel municipal con NA se imputa con cero
df <- df %>% mutate_all(~replace(., is.na(.), 0))
# Crea variable de penetracion de BAF por cada 100 hogares y la penetracion de cable coaxial + fibra optica
df <- df %>% mutate(PEN_BAF = df$ALL_ACCESS/df$HOGARES*100)
df$PEN_BAF_COAXFO <- 0
for (i in 1:nrow(df)){
df$PEN_BAF_COAXFO[i]<- df$COAX_FO[i]/df$HOGARES[i]*100
}
# Crea variable de densidad de hogares por kilometros cuadrados
#df <- df %>% mutate(DENS_HOGS = df$HOGARES/df$SUPERFICIE)
df$DENS_HOGS <- 0
for (i in 1:nrow(df)){
df$DENS_HOGS[i]<- df$HOGARES[i]/df$SUPERFICIE[i]*100
}
# Creamos una columna para clasificar los municipios segun su grado de penetracion.
#La clasificación de Penetracion de Fibra Óptica y Cable Coaxial:
# Sin cobertura=0
# Muy baja 0>25%
# Baja 25%>50%
# Media 50%>75%
# Alta 75%>100%
# Muy Alta 100%
df$PEN_CLASS <- NA
for (index in 1:nrow(df)){
df$PEN_CLASS[index] <- if_else(df$PEN_BAF_COAXFO[index]==0,0,
if_else(df$PEN_BAF_COAXFO[index]<=25,1,
if_else(df$PEN_BAF_COAXFO[index]<=50,2,
if_else(df$PEN_BAF_COAXFO[index]<=75,3,
if_else(df$PEN_BAF_COAXFO[index]<=100,4,5)))))
}
#----- Agregamos una columna que nos diga la region socioecnomica a la que pertenece el municipio
RegionesSocioEcono <- read_csv("RegionesSocioEcono.csv",
col_types = cols(NOM_ABRE_ENTIDAD = col_skip(),
NOM_ENTIDAD = col_skip(), NUM = col_skip()))
df <- df %>% mutate(K_ENTIDAD = substr(K_ENTIDAD_MUNICIPIO,1,2))
df <- left_join(df,RegionesSocioEcono, by = "K_ENTIDAD")
df$K_ENTIDAD<-NULL
for (index in 1:nrow(df)){
df$REG_SOCIOECONOM[index] <- if_else(df$REG_SOCIOECONOM[index]=="Centronorte",1,
if_else(df$REG_SOCIOECONOM[index]=="Centrosur",2,
if_else(df$REG_SOCIOECONOM[index]=="Noreste",3,
if_else(df$REG_SOCIOECONOM[index]=="Noroeste",4,
if_else(df$REG_SOCIOECONOM[index]=="Occidente",5,
if_else(df$REG_SOCIOECONOM[index]=="Oriente",6,
if_else(df$REG_SOCIOECONOM[index]=="Sureste",7,8)))))))
}
View(df)
getwd()
glimpse(df)
library(readr)
library(tidyverse)
library(readxl)
# Establece directorio de trabajo
setwd("/media/Box/Aprendizaje_Maquina/Projecto")
# Crear las bases de datos para trabajar
source("creating_baf.R") # Accesos de banda ancha fija a junio/2019 BIT del IFT
source("creating_conapo.R") # Indice marginacion y porcentaje pob con menos de 2 salarios min, 2015 CONAPO
source("creating_inafed.R") # Superficie de municipios, INAFED
source("creating_indiceinfraestructura.R")  # Indice infraestructura TII - centro de estudios IFT
source("creating_hogares.R") # Hogares por municipios Encuesta intercensal 2015, INEGI
source("creating_poblacion.R") # Poblacion por municipios Encuesta intercensal 2015, INEGI
# Elimina variables auxiliares
rm(index, left_path,name_state,right_path,states_list,cleaning_hog_state,cleaning_pop_state)
# Consolidamos las bases
df <- left_join(hogares2015,poblacion2015, by = "K_ENTIDAD_MUNICIPIO")
df <- left_join(df,conapo, by = "K_ENTIDAD_MUNICIPIO")
df <- left_join(df,INAFED, by = "K_ENTIDAD_MUNICIPIO")
df <- left_join(df,infraestructura_index, by = "K_ENTIDAD_MUNICIPIO")
df <- left_join(df,BAF_062019, by = "K_ENTIDAD_MUNICIPIO")
df$SUPERFICIE<- as.numeric(df$SUPERFICIE)
df$PO2SM<- as.numeric(df$PO2SM)
# Se eliminan columas sin interes para el analisis
df$K_ENTIDAD<-NULL
df$K_MUNICIPIO<-NULL
df$ANIO<-NULL
df$MES<-NULL
## El detalle de accesos a nivel municipal con NA se imputa con cero
df <- df %>% mutate_all(~replace(., is.na(.), 0))
# Crea variable de penetracion de BAF por cada 100 hogares y la penetracion de cable coaxial + fibra optica
df <- df %>% mutate(PEN_BAF = df$ALL_ACCESS/df$HOGARES*100)
df$PEN_BAF_COAXFO <- 0
for (i in 1:nrow(df)){
df$PEN_BAF_COAXFO[i]<- df$COAX_FO[i]/df$HOGARES[i]*100
}
# Crea variable de densidad de hogares por kilometros cuadrados
#df <- df %>% mutate(DENS_HOGS = df$HOGARES/df$SUPERFICIE)
df$DENS_HOGS <- 0
for (i in 1:nrow(df)){
df$DENS_HOGS[i]<- df$HOGARES[i]/df$SUPERFICIE[i]*100
}
# Creamos una columna para clasificar los municipios segun su grado de penetracion.
#La clasificación de Penetracion de Fibra Óptica y Cable Coaxial:
# Sin cobertura=0
# Muy baja 0>25%
# Baja 25%>50%
# Media 50%>75%
# Alta 75%>100%
# Muy Alta 100%
df$PEN_CLASS <- NA
for (index in 1:nrow(df)){
df$PEN_CLASS[index] <- if_else(df$PEN_BAF_COAXFO[index]==0,0,
if_else(df$PEN_BAF_COAXFO[index]<=25,1,
if_else(df$PEN_BAF_COAXFO[index]<=50,2,
if_else(df$PEN_BAF_COAXFO[index]<=75,3,
if_else(df$PEN_BAF_COAXFO[index]<=100,4,5)))))
}
#----- Agregamos una columna que nos diga la region socioecnomica a la que pertenece el municipio
RegionesSocioEcono <- read_csv("RegionesSocioEcono.csv",
col_types = cols(NOM_ABRE_ENTIDAD = col_skip(),
NOM_ENTIDAD = col_skip(), NUM = col_skip()))
df <- df %>% mutate(K_ENTIDAD = substr(K_ENTIDAD_MUNICIPIO,1,2))
df <- left_join(df,RegionesSocioEcono, by = "K_ENTIDAD")
df$K_ENTIDAD<-NULL
for (index in 1:nrow(df)){
df$REG_SOCIOECONOM[index] <- if_else(df$REG_SOCIOECONOM[index]=="Centronorte",1,
if_else(df$REG_SOCIOECONOM[index]=="Centrosur",2,
if_else(df$REG_SOCIOECONOM[index]=="Noreste",3,
if_else(df$REG_SOCIOECONOM[index]=="Noroeste",4,
if_else(df$REG_SOCIOECONOM[index]=="Occidente",5,
if_else(df$REG_SOCIOECONOM[index]=="Oriente",6,
if_else(df$REG_SOCIOECONOM[index]=="Sureste",7,8)))))))
}
glimpse(df)
df1<- df %>% select(HOGARES, POBLACION, PO2SM, IM, SUPERFICIE, INFRA_INDEX, ALL_ACCESS, NUM_OPS, DENS_HOGS, REG_SOCIOECONOM)
View(df1)
nrow(df1)
glimpse(df1)
df1<- df %>% select(HOGARES, POBLACION, PO2SM, IM, SUPERFICIE, INFRA_INDEX, ALL_ACCESS, NUM_OPS, DENS_HOGS, REG_SOCIOECONOM)
write_csv(df1, "BAF_06209_selected.csv")
df1<- df %>% select(HOGARES, POBLACION, PO2SM, IM, SUPERFICIE, INFRA_INDEX, ALL_ACCESS, NUM_OPS, DENS_HOGS, PEN_CLASS)
write_csv(df1, "BAF_06209_selected.csv")
